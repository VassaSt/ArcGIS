//  creation ui for data item
  // <div class="layer-list">
  // <button id="btn" class="layer-list__item">
  //     <div class="item-title__wrap">
  //       <div class="item-marker"></div>
  //       <div class="item-title" id="layer-name"></div>
  //     </div>
  //     <div class="item-eye"></div>
  //   </button>
  // </div>





        buttons = document.querySelectorAll('.item-eye');
        // console.log("buttons : ", buttons);

    let buttonPressed = e => {

      // let layer_id = this.getAttribute('value');
  // console.log("layer_id: ", layer_id);
  // reearth.layers.layers;
  // if (this.classList.contains('item-eye')){
  //   reearth.layers.hide(layer_id);

  //   this.classList.remove('item-eye');
  //   this.classList.add('item-eye__closed');
  // } else {
  //   reearth.layers.show(layer_id);

  //   this.classList.remove('item-eye__closed');
  //   this.classList.add('item-eye');
  // }


      // Get ID of Clicked Element
      let layer_id = e.target.parentElement.id;
      console.log(layer_id);
      console.log(e.target);

    //   // getting properties from selected option 
    //   function onChange() {
    //     var imageUrl = markersList.options[markersList.selectedIndex].value;
    //     var imageSize = markersList.options[markersList.selectedIndex].getAttribute('imageSize');
    //     let imageSizeToNumber = +imageSize;

    //     reearth.layers.overrideProperty((markerId), {
    //       default: {
    //         image: imageUrl,
    //         imageSize: imageSizeToNumber,
    //       }
    //     });

      // }
      // markersList.onchange = onChange;
      // onChange();

    }
    for (let button of buttons) {
      button.addEventListener("click", buttonPressed);
    }


            // document.getElementById(itemTitle__wrapID).addEventListener('click', download);
        // document.getElementById(itemEyeID).addEventListener('click', handleLayer);


              for (let i = 0; i < geoJsonData.features.length; i++) {
                if ((geoJsonData.features[i].geometry.type === "LineString") || (geoJsonData.features[i].geometry.type === "MultiLineString")) {
                  lines.push(geoJsonData.features[i])
                } else if ((geoJsonData.features[i].geometry.type === "Point") || (geoJsonData.features[i].geometry.type === "MultiPoint")){
                  points.push(geoJsonData.features[i])
                } else if ((geoJsonData.features[i].geometry.type === "Polygon") || (geoJsonData.features[i].geometry.type === "MultiPolygon")) {
                  polygons.push(geoJsonData.features[i])
                }
              }



          // let jsonProperties = JSON.stringify(result);
          // console.log("test", jsonProperties);

        //       if (result) {
        //         let jsonProperties = JSON.stringify(result);
        //     geojson.features.forEach(function (feature) {
        //             feature.properties = JSON.parse(jsonProperties);
        //           })

        //     let geoJsonString = JSON.stringify(geojson);

        //     let blob = new Blob([geoJsonString], { type: 'application/json' });
        //     let link = URL.createObjectURL(blob);

        //   // override
        //   reearth.layers.overrideProperty(layerId, {
        //     default: {
        //       url: link,
        //     },
        //   });
        // } else {
        //   console.log("point");
         }



                  - id: outline_width
            type: number
            title: Outline width
            suffix: px
            availableIf:
                field: data_type
                type: string
                value: polygon




                {
          reearth.layers.overrideProperty((markerId), {
            default: {
              url: [],
            }
          });

          reearth.layers.overrideProperty((markerId), {
            default: {
              image: imageUrl,
              imageSize: imageSize,
            }
          });
          
        } else 






    function overridePolygonProperties(polygons, layerId, polygonFill, polygonProp) {
      let lineString
      let geoJson = turf.featureCollection([]);
      let multi = turf.featureCollection([]);
      let poly= turf.featureCollection([]);
      console.log(polygons);

      for (let i = 0; i < polygons.features.length; i++) {
        if (polygons.features[i].geometry.type == "MultiPolygon") {
          multi.features.push(polygons.features[i])
          // console.log(multi);
        } else {
          poly.features.push(polygons.features[i])
          // console.log(poly);
        }
      }
// console.log(multi, poly);

      // if (multi.features.length > 0){
      //     turf.featureEach(multi, function (currentFeature, featureIndex) {
      //     currentFeature.properties["fill"] = polygonFill;
      //     let multipoligonCoords = turf.getCoords(currentFeature);
      //     turf.featureEach(multipoligonCoords, function (feature, featureIndex) {
      //     let line = turf.multiLineString(turf.getCoords(feature)[0]);
      //     line.properties = polygonProp;
      //     console.log("line: ", line);
      //     multi.features.push(line);

      //     })
      //   })
      //   console.log(multi);
      // }

      // if (poly.features.length > 0) {
      //   turf.featureEach(poly, function (currentFeature, featureIndex) {
      //     currentFeature.properties["fill"] = polygonFill;
      //     currentFeature.properties["stroke-width"] = 0;
      //     linestring = turf.lineString(turf.getCoords(currentFeature)[0])
      //     linestring.properties["stroke"] = polygonProp.stroke;
      //     poly.features.push(linestring);
      //   })
      //   console.log(poly.features.length);
      //   }


      // overriding properties by type MultiPolygon or Polygon
        // console.log("elm:", element)
        // if (element.geometry.type == "MultiPolygon") {
          // console.log("handle multipolygon")

          turf.featureEach(multi, function (currentFeature) {
          currentFeature.properties["fill"] = polygonFill;
          let multipoligonCoords = turf.getCoords(currentFeature);
          multipoligonCoords.forEach((e) => {
            let line = turf.multiLineString(turf.getCoords(e));
          line.properties = polygonProp;
          geoJson.features.push(currentFeature);
          geoJson.features.push(line);
          })
        });

        // } else 
        
        // if (element.geometry.type == "Polygon") {
          // console.log("handle polygonnn")
          turf.featureEach(poly, function (currentFeature, featureIndex) {
            currentFeature.properties["fill"] = polygonFill;
            currentFeature.properties["stroke-width"] = 0;
          linestring = turf.lineString(turf.getCoords(currentFeature)[0])
          linestring.properties["stroke"] = polygonProp.stroke
          geoJson.features.push(currentFeature);
          geoJson.features.push(linestring);

        })


      // multi.features.map((element) => {
      //   geoJson.features.push(element)
      // });

      // poly.features.map((element) => {
      //   geoJson.features.push(element)
      // });


      // geoJson.features.push(poly.features, multi.features);


console.log("geoJson :", geoJson);

      // console.log("Polygon geoJson :", geoJson);
      // console.log("layerId :", layerId);

      parent.postMessage({ type: "Properties", layerId, geoJson }, "*");
    }
    //  ./overridePolygonProperties



      if ((data.type == "FeatureCollection")) {
        let polygonProp = ({ "stroke": "#000000", "stroke-width": "2" });
        let geoJson = turf.featureCollection([]);
        data.features.map((element) => {
          if (element.geometry.type == "MultiPolygon") {

            turf.featureEach(data, function (currentFeature) {
              currentFeature.properties["fill"] = "yellow";
              let multipoligonCoords = turf.getCoords(currentFeature);
              multipoligonCoords.forEach((e) => {
                let line = turf.multiLineString(turf.getCoords(e)[0]);
                line.properties = polygonProp;
                geoJson.features.push(currentFeature);
                geoJson.features.push(line);
              })
            });
          }
          console.log(geoJson);
          // data = geoJson;
        });


        // muliPoligon
      }